from flask import Flask, request, render_template, session, redirect,url_for
#from sklearn.externals import joblib
import pandas as pd 
import dask.dataframe as dd
import numpy as np
import lightgbm as lgb
from sklearn.preprocessing import LabelEncoder
import joblib


app = Flask(__name__,template_folder='Templates')

@app.route('/',methods=['POST','GET'])
def welcome():
	if request.method == 'POST':
		if request.form.get('predictions') == 'click  here to predict':
			return redirect(url_for('predict'))
	return render_template("index.html")


	


dtype = {
		'MachineIdentifier':                                    'category',
		'ProductName':                                          'category',
		'EngineVersion':                                        'category',
		'AppVersion':                                           'category',
		'AvSigVersion':                                         'category',
		'IsBeta':                                               'int8',
		'RtpStateBitfield':                                     'float16',
		'IsSxsPassiveMode':                                     'int8',
		'DefaultBrowsersIdentifier':                            'float16',
		'AVProductStatesIdentifier':                            'float32',
		'AVProductsInstalled':                                  'float16',
		'AVProductsEnabled':                                    'float16',
		'HasTpm':                                               'int8',
		'CountryIdentifier':                                    'int16',
		'CityIdentifier':                                       'float32',
		'OrganizationIdentifier':                               'float16',
		'GeoNameIdentifier':                                    'float16',
		'LocaleEnglishNameIdentifier':                          'int8',
		'Platform':                                             'category',
		'Processor':                                            'category',
		'OsVer':                                                'category',
		'OsBuild':                                              'int16',
		'OsSuite':                                              'int16',
		'OsPlatformSubRelease':                                 'category',
		'OsBuildLab':                                           'category',
		'SkuEdition':                                           'category',
		'IsProtected':                                          'float16',
		'AutoSampleOptIn':                                      'int8',
		'PuaMode':                                              'category',
		'SMode':                                                'float16',
		'IeVerIdentifier':                                      'float16',
		'SmartScreen':                                          'category',
		'Firewall':                                             'float16',
		'UacLuaenable':                                         'float32',
		'Census_MDC2FormFactor':                                'category',
		'Census_DeviceFamily':                                  'category',
		'Census_OEMNameIdentifier':                             'float16',
		'Census_OEMModelIdentifier':                            'float32',
		'Census_ProcessorCoreCount':                            'float16',
		'Census_ProcessorManufacturerIdentifier':               'float16',
		'Census_ProcessorModelIdentifier':                      'float16',
		'Census_ProcessorClass':                                'category',
		'Census_PrimaryDiskTotalCapacity':                      'float32',
		'Census_PrimaryDiskTypeName':                           'category',
		'Census_SystemVolumeTotalCapacity':                     'float32',
		'Census_HasOpticalDiskDrive':                           'int8',
		'Census_TotalPhysicalRAM':                              'float32',
		'Census_ChassisTypeName':                               'category',
		'Census_InternalPrimaryDiagonalDisplaySizeInInches':    'float16',
		'Census_InternalPrimaryDisplayResolutionHorizontal':    'float16',
		'Census_InternalPrimaryDisplayResolutionVertical':      'float16',
		'Census_PowerPlatformRoleName':                         'category',
		'Census_InternalBatteryType':                           'category',
		'Census_InternalBatteryNumberOfCharges':                'float32',
		'Census_OSVersion':                                     'category',
		'Census_OSArchitecture':                                'category',
		'Census_OSBranch':                                      'category',
		'Census_OSBuildNumber':                                 'int16',
		'Census_OSBuildRevision':                               'int32',
		'Census_OSEdition':                                     'category',
		'Census_OSSkuName':                                     'category',
		'Census_OSInstallTypeName':                             'category',
		'Census_OSInstallLanguageIdentifier':                   'float16',
		'Census_OSUILocaleIdentifier':                          'int16',
		'Census_OSWUAutoUpdateOptionsName':                     'category',
		'Census_IsPortableOperatingSystem':                     'int8',
		'Census_GenuineStateName':                              'category',
		'Census_ActivationChannel':                             'category',
		'Census_IsFlightingInternal':                           'float16',
		'Census_IsFlightsDisabled':                             'float16',
		'Census_FlightRing':                                    'category',
		'Census_ThresholdOptIn':                                'float16',
		'Census_FirmwareManufacturerIdentifier':                'float16',
		'Census_FirmwareVersionIdentifier':                     'float32',
		'Census_IsSecureBootEnabled':                           'int8',
		'Census_IsWIMBootEnabled':                              'float16',
		'Census_IsVirtualDevice':                               'float16',
		'Census_IsTouchEnabled':                                'int8',
		'Census_IsPenCapable':                                  'int8',
		'Census_IsAlwaysOnAlwaysConnectedCapable':              'float16',
		'Wdft_IsGamer':                                         'float16',
		'Wdft_RegionIdentifier':                                'float16',
		'HasDetections':                                        'int8'
		}


def reduce_memory(data):  
    for col in data:
        column_type = str(data[col].dtypes)
        types = ['int16','int32','int64','float16','float32','float64']
        if column_type in types:
            min_value = data[col].min()
            max_value = data[col].max()
      
            if column_type[:3] == 'int':
                if min_value > np.iinfo(np.int8).min and max_value < np.iinfo(np.int8).max:
                    data[col]=data[col].astype(np.int8) 
                elif min_value > np.iinfo(np.int16).min and max_value < np.iinfo(np.int16).max:
                    data[col]=data[col].astype(np.int16)
                elif min_value > np.iinfo(np.int32).min and max_value < np.iinfo(np.int32).max:
                    data[col]=data[col].astype(np.int32)
                elif min_value > np.iinfo(np.int64).min and max_value < np.iinfo(np.int64).max:
                    data[col]=data[col].astype(np.int64)
      
            else:

                if min_value > np.finfo(np.float16).min and max_value < np.finfo(np.float16).max:
                    data[col]=data[col].astype(np.float16) 
                elif min_value > np.finfo(np.float32).min and max_value < np.finfo(np.float32).max:
                    data[col]=data[col].astype(np.float32)
                else:

                    data[col]=data[col].astype(np.float64)
    return data


def remove_columns(data):
    columns_to_be_removed = []
    percent = (data.isnull().sum()/data.shape[0]) * 100

    for col in data.columns:
        if percent.loc[col] >= 70:
            columns_to_be_removed.append(col)
    new_data = data.drop(columns=columns_to_be_removed)
  
    return new_data


def replace_smartscreen(val):
    val = val.lower()
    if val in 'block':
        return 'block'
    elif val in 'existsnotset':
        return 'existnotset'
    elif val in 'off':
        return 'off'
    elif val in 'prompt':
        return 'prompt'
    elif val in 'requireadmin':
        return 'requireadmin'
    elif val in 'warn':
        return 'warn'
    elif val in 'on':
        return 'on'
    else:
        return 'unknown'


def replace_channel(val):
    val = val.lower()
    if 'oem' in val:
        return 'oem'
    elif 'retail' in val:
        return 'retail'
    elif 'volume' in val:
        return 'volume'
    else:
        return val



def replace_edition(val):
    val = val.lower()
    if 'cloud' in val:
        return val
    elif 'core' in val:
        return 'core'
    elif 'education' in val:
        return 'education'
    elif 'enterprise' in val:
        return 'enterprise'
    elif 'pro' in val:
        return 'pro'
    elif 'server' in val:
        return 'server'
    elif 'home' in val:
        return 'home'
    else:
        return val


def replace_skuname(val):
    val = val.lower()
    if 'cloud' in val:
        return val
    elif 'core' in val:
        return 'core'
    elif 'education' in val:
        return 'education'
    elif 'enterprise' in val:
        return 'enterprise'
    elif 'pro' in val:
        return 'pro'
    elif 'server' in val:
        return 'server'
    elif 'home' in val:
        return 'home'
    else:
        return val



def fill_missing_values(data,features):
    numerical_features = features[0]
    binary_features = features[1]
    categorical_features = features[2]
    # replacing null values with -1 in in numerical features
    for feature in numerical_features:
        data[feature] = data[feature].fillna(-1)
    # replaceing null values with mode value of that feature in binary features
    for feature in binary_features:
        data[feature] = data[feature].fillna(data[feature].mode()[0])
    data['SmartScreen'] = data['SmartScreen'].apply(replace_smartscreen) 
    data['SmartScreen'] = data['SmartScreen'].astype('category')
    data['Census_OSSkuName'] = data['Census_OSSkuName'].apply(replace_skuname)
    data['Census_OSSkuName'] = data['Census_OSSkuName'].astype('category')
    data['Census_OSEdition'] = data['Census_OSEdition'].apply(replace_edition)
    data['Census_OSEdition'] = data['Census_OSEdition'].astype('category') 
    data['Census_ActivationChannel'] = data['Census_ActivationChannel'].apply(replace_channel)
    data['Census_ActivationChannel'] = data['Census_ActivationChannel'].astype('category')     
    data['Census_ChassisTypeName'].replace(['UNKNOWN','Unknown','Other'],'unknown',inplace=True)
    data['Census_ChassisTypeName'] = data['Census_ChassisTypeName'].astype('category')
    data['Census_PowerPlatformRoleName'].replace(['UNKNOWN','Unspecified'],'unknown',inplace=True)
    data['Census_PowerPlatformRoleName'] = data['Census_PowerPlatformRoleName'].astype('category')
    data['Census_FlightRing'].replace(['Invalid','Unknown'],'unknown',inplace=True)
    data['Census_FlightRing'] = data['Census_FlightRing'].astype('category')
    data['Census_OSSkuName'].replace(['UNDEFINED'],'unknown',inplace=True)
    data['Census_OSSkuName'] = data['Census_OSSkuName'].astype('category')
    data['SkuEdition'].replace(['Invalid'],'unknown',inplace=True)
    data['SkuEdition'] = data['SkuEdition'].astype('category')
    data['Census_OSWUAutoUpdateOptionsName'].replace(['UNKNOWN'],'unknown',inplace=True)
    data['Census_OSWUAutoUpdateOptionsName'] = data['Census_OSWUAutoUpdateOptionsName'].astype('category')
    data['Census_PrimaryDiskTypeName'].replace(['UNKNOWN','Unspecified'],'unknown',inplace=True)
    data['Census_PrimaryDiskTypeName'] = data['Census_PrimaryDiskTypeName'].astype('category')
    data['Census_GenuineStateName'].replace(['UNKNOWN'],'unknown',inplace=True)
    data['Census_GenuineStateName'] = data['Census_GenuineStateName'].astype('category')

    # replacing null values by adding category called 'unknown' in categorical features
    for feature in categorical_features:
        if 'unknown' not in data[feature].cat.categories:
            data[feature] = data[feature].cat.add_categories(['unknown'])
            data[feature] = data[feature].fillna('unknown')
        else:
            data[feature] = data[feature].fillna('unknown')

    return data



def feature_engineering(data):
    data['Remaining_Disks_Capacity'] = data['Census_PrimaryDiskTotalCapacity'] - data['Census_SystemVolumeTotalCapacity']
    data['Remaining_Disks_Capacity'] = data['Remaining_Disks_Capacity'].fillna(-1)
    data['C_drive_capacity'] = data['Census_SystemVolumeTotalCapacity'] / data['Census_PrimaryDiskTotalCapacity']
    data['C_drive_capacity'] = data['C_drive_capacity'].fillna(-1)
    data['gamer_with_firewall'] = (data['Wdft_IsGamer'] + data['Firewall']) % 2
    data['gamer_with_firewall'] = data['gamer_with_firewall'].fillna(data['gamer_with_firewall'].mode()[0])
    data['gamer_protected'] = (data['Wdft_IsGamer'] + data['IsProtected']) % 2
    data['gamer_protected'] = data['gamer_protected'].fillna(data['gamer_protected'].mode()[0])
    data['ram_by_processor'] = data['Census_TotalPhysicalRAM'] / data['Census_ProcessorCoreCount']
    data['ram_by_processor'] = data['ram_by_processor'].fillna(-1)
    data['portable_os_protected'] = (data['Census_IsPortableOperatingSystem'] + data['IsProtected']) % 2
    data['portable_os_protected'] = data['portable_os_protected'].fillna(data['portable_os_protected'].mode()[0])
    data['dimensions'] = data['Census_InternalPrimaryDisplayResolutionHorizontal'].astype(str) + '*' + data['Census_InternalPrimaryDisplayResolutionVertical'].astype(str)
    
    data['dimensions'] = data['dimensions'].astype('category')
    data['optical_drive_protected'] = (data['Census_HasOpticalDiskDrive'] + data['IsProtected']) % 2
    data['Connected_total_capacity'] = (data['Census_SystemVolumeTotalCapacity'] / (data['Census_IsAlwaysOnAlwaysConnectedCapable'] + 1))
    data['optical_drive_protected'] = data['optical_drive_protected'].fillna(data['optical_drive_protected'].mode()[0])
    data['secure_boot_protected'] = (data['Census_IsSecureBootEnabled'] + data['IsProtected']) % 2
    data['secure_boot_protected'] = data['secure_boot_protected'].fillna(data['secure_boot_protected'].mode()[0])
    data['transformed_build_revision'] = np.log(data['Census_OSBuildRevision'])
    data['transformed_build_revision'] = data['transformed_build_revision'].fillna(-1)
    data['vertical_display_by_inches'] = data['Census_InternalPrimaryDisplayResolutionVertical'] / data['Census_InternalPrimaryDiagonalDisplaySizeInInches']
    data['vertical_display_by_inches'] = data['vertical_display_by_inches'].fillna(-1)
    return data

def frequency_encoding(feature,data):
    encoded_dict = data[feature].value_counts().to_dict()
    return encoded_dict


def encode_categorical_features(final_data,frequency_encoded_features,final_categorical_features):
    
    for i in frequency_encoded_features:
        encoded_values = frequency_encoding(i,final_data)
        final_data[i] = final_data[i].map(lambda x : encoded_values.get(str(x),0))
        final_data[i] = final_data[i].astype('int64')
    for i in final_categorical_features:
        le = LabelEncoder()
        final_data[i] = le.fit_transform(final_data[i])
        final_data[i] = final_data[i].astype('int64')
    return final_data


def types_of_features(data):
	total_features = data.columns
	numerical_features = list(data._get_numeric_data().columns)
	binary_features = []
	categorical_features = list(set(total_features) - set(numerical_features))
	for i in numerical_features:
		if (data[str(i)].min() == 0 and data[str(i)].max() == 1) and data[str(i)].min()== 0:
			binary_features.append(i)
	numerical_features = list(set(numerical_features)- set(binary_features))
	return numerical_features,binary_features,categorical_features




def preprocessing_test(data):    
    categorical_features = list(np.load('categorical.npz')['arr_0']) # loads categorical features which are in train data set
    binary_features = list(np.load('binary.npz')['arr_0']) # loads binary features which are in train data set
    numerical_features = list(np.load('numerical.npz')['arr_0']) # loads numerical features which are in train data set
    features = (numerical_features,binary_features,categorical_features)
    data = data[numerical_features+binary_features+categorical_features]
    
    data = fill_missing_values(data,features)
    
    categorical_features_to_be_removed = list(np.load('highly_correlated_categorical_features.npz')['arr_0'])
    numerical_features_to_be_removed = list(np.load('highly_correlated_numerical_features.npz')['arr_0'])
    binary_features_to_be_removed = list(np.load('highly_correlated_binary_features.npz')['arr_0'])
    columns_to_be_dropped = categorical_features_to_be_removed + numerical_features_to_be_removed + binary_features_to_be_removed
    data = data.drop(columns=columns_to_be_dropped)
    
    return data


@app.route('/predict')
def predict():
	test_data = dd.read_csv('test.csv',dtype=dtype)
	test_data = test_data.compute()
	test_data = reduce_memory(test_data)
	newdata = test_data.copy()
	identifier = newdata['MachineIdentifier']
	newdata = newdata.drop(columns=['MachineIdentifier'])
	final_X = preprocessing_test(newdata)
	final_X = feature_engineering(final_X)
	numerical_features,binary_features,categorical_features = types_of_features(final_X)
	frequency_encoded_features = ['AppVersion','AvSigVersion','Census_OSVersion','OsVer','EngineVersion']
	final_categorical_features = list(set(categorical_features) - set(frequency_encoded_features))
	final_X = encode_categorical_features(final_X,frequency_encoded_features,final_categorical_features)
	clf = joblib.load('lightgbm_best_model_after_feature_selection.pkl')
	predictions = clf.predict_proba(final_X)[:,1]
	final_prediction = pd.DataFrame({'MachineIdentifier' :  identifier,'Probabilities' : predictions})
	#value = final_prediction.iloc[0]
	#ident = final_prediction['MachineIdentifier'].values()[:10]

	#value = 
	#predict_data = {ident:prediction}
	return final_prediction.to_html()
	#return render_template('index.html',tables=[final_prediction.to_html(classes='data',header='true')])


if __name__ == '__main__':
	app.run(debug=True)